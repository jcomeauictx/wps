%%% (c) 2009 Tomas Hlavaty

currentdict/systemdict currentdict put
systemdict/{/mark cvx put
systemdict/[/mark cvx put
systemdict/]
/counttomark cvx
/array cvx
/astore cvx
/exch cvx
/pop cvx
5 array astore cvx put
systemdict/}/] cvx/cvx cvx 2 array astore cvx put
systemdict/def{currentdict 2 index 2 index put pop pop}put

%% stack & dict

/dup{0 index}def
/cleartomark{array pop}def

/known{exch begin where{currentdict eq}{false}if end}def
/store{1 index where{3 1 roll put}{def}ifelse}def
/load{dup where pop exch get}def

/maxlength 1000 def % TODO

%% conditionals

/true/.true load def
/false/.false load def
/null/.null load def

/not{false true ifelse}def
/.logand{{{true}{false}ifelse}{pop false}ifelse}def
/and/.logand load def % TODO numeric and
/.logor{{pop true}{{true}{false}ifelse}ifelse}def
/or/.logor load def % TODO numeric or

/ne{eq not}def
/ge{lt not}def
/le{1 index 1 index eq 3 1 roll lt or}def
/gt{le not}def
/if{{}ifelse}def

/.repeat{1 1 4 2 roll for}def
%//     var B = Os.pop();
%//     var N = Os.pop();
%//     if(1 < N) Es.push([true, N - 1, B, Xrepeat]);
%//     if(0 < N) Es.push([false, B, Xexec]);
% /repeat{ % n b
%   exch 2 copy dup % b n, b n n
%   1 gt{-1 add exch/repeat cvx exec}{pop pop}ifelse
%   0 gt{exec}{pop}ifelse
% } def
% /repeat{ % n b
%   exch % b n
%   2 copy % b n b n
%   0 gt pstack{exec}{pop}ifelse % b n
%   pop pop
% %  dup 1 gt{-1 add exch repeat}{pop pop}ifelse
% } def
% /repeat { % n b
%   2 dict begin
%     /b exch def
%     /n exch def
%     0 n lt b if
%     1 n lt {n 1 sub b repeat} if
%   end
% } def
%/repeat{/pop cvx exch/exec cvx 3 array astore cvx 1 1 4 2 roll for}def
%/loop{0 exch 0 exch 1 exch for}def % TODO
%/exit{}def % TODO

%% math

/neg{0 exch sub}def
/add{neg sub}def
/idiv{div floor}def

/abs{.math(abs)1 .call}def
/.acos{.math(acos)1 .call}def
/.asin{.math(asin)1 .call}def
/atan{exch .math(atan)1 .call}def
/.atan2{.math(atan2)2 .call}def
/ceiling{.math(ceil)1 .call}def
/cos{.math(cos)1 .call}def
/.exp{.math(exp)1 .call}def
/floor{.math(floor)1 .call}def
/log{.math(log)1 .call}def
/.max{.math(max)2 .call}def
/.min{.math(min)2 .call}def
/.pow{.math(pow)2 .call}def
/.random{.math(random)0 .call}def
/rand{.random}def % TODO follow spec
/round{.math(round)1 .call}def
/sin{.math(sin)1 .call}def
/sqrt{.math(sqrt)1 .call}def
/.tan{.math(tan)1 .call}def
/truncate{.math(truncate)1 .call}def % TODO Math.truncate does not exist!

/.e{.math(E)get}def
/.ln2{.math(LN2)get}def
/.ln10{.math(LN10)get}def
/.log2e{.math(LOG2E)get}def
/.log10e{.math(LOG10E)get}def
/.pi{.math(PI)get}def
/.sqrt1_2{.math(SQRT1_2)get}def
/.sqrt2{.math(SQRT2)get}def

%% html

/.setTimeout{.window(setTimeout)2 .call}def % cb ms -- id
/.clearTimeout{.window(clearTimeout)1 .call pop}def % id --
/.setInterval{.window(setInterval)2 .call}def % cb ms -- id
/.clearInterval{.window(clearInterval)1 .call pop}def % id --
/.document{.window(document)get}def % -- document
/.getElementById{.document(getElementById)1 .call}def % id -- w

%/.attachEvent{3 2 roll(attachEvent)2 .call pop}def % e k fn --
%/.setAttribute{3 2 roll(setAttribute)2 .call pop}def % e k v --
/.hook{put}def % e k cb --
%if( td.attachEvent ) td.attachEvent('onclick', 'alert("blabla")');
% else td.setAttribute('onclick', 'alert("blabla")');

%% html5

/.gget{.gc exch get}def
/.gput{.gc 3 1 roll exch put}def
/.gcall0{.gc 3 1 roll .call pop}def
/.gcall1{.gc 3 1 roll .call}def
/.gcanvas{(canvas).gget}def
/.gdim{.gcanvas exch(height)exch put .gcanvas exch(width)exch put}def
/.gbox{.gdim pop pop} def % TODO compute properly

%% canvas

/.save{(save)0 .gcall0}def
/.restore{(restore)0 .gcall0}def
/.scale{(scale)2 .gcall0}def
/.rotate{(rotate)1 .gcall0}def
/.translate{(translate)2 .gcall0}def
/.transform{(transform)6 .gcall0}def
/.setTransform{(setTransform)6 .gcall0}def
/.createLinearGradient{(createLinearGradient)4 .gcall1}def
/.createRadialGradient{(createRadialGradient)6 .gcall1}def
/.createPattern{(createPattern)2 .gcall1}def
/.clearRect{(clearRect)4 .gcall0}def
/.fillRect{(fillRect)4 .gcall0}def
/.strokeRect{(strokeRect)4 .gcall0}def
/.beginPath{(beginPath)0 .gcall0}def
/.closePath{(closePath)0 .gcall0}def
/.moveTo{(moveTo)2 .gcall0}def
/.lineTo{(lineTo)2 .gcall0}def
/.quadraticCurveTo{(quadraticCurveTo)4 .gcall0}def
/.bezierCurveTo{(bezierCurveTo)6 .gcall0}def
/.arcTo{(arcTo)5 .gcall0}def
/.rect{(rect)4 .gcall0}def
/.arc{(arc)6 .gcall0}def
/.fill{(fill)0 .gcall0}def
/.stroke{(stroke)0 .gcall0}def
/.clip{(clip)0 .gcall0}def
/.isPointInPath{(isPointInPath)2 .gcall1}def
/.fillText{(fillText)4 .gcall0}def
/.fillText{}def % TODO not working in Firefox
/.strokeText{(strokeText)4 .gcall0}def
/.strokeText{}def % TODO not working in Firefox
/.measureText{(measureText)1 .gcall1}def
/.drawImage1{(drawImage1)5 .gcall0}def
/.drawImage2{(drawImage2)9 .gcall0}def
/.createImageData1{(createImageData1)1 .gcall1}def
/.createImageData2{(createImageData2)2 .gcall1}def
/.getImageData{(getImageData)4 .gcall1}def
/.putImageData{(putImageData)7 .gcall0}def

/.getGlobalAlpha{(globalAlpha).gget}def
/.getGlobalCompositeOperation{(globalCompositeOperation).gget}def
/.getStrokeStyle{(strokeStyle).gget}def
/.getFillStyle{(fillStyle).gget}def
/.getLineWidth{(lineWidth).gget}def
/.getLineCap{(lineCap).gget}def
/.getLineJoin{(lineJoin).gget}def
/.getMiterLimit{(miterLimit).gget}def
/.getShadowOffsetX{(shadowOffsetX).gget}def
/.getShadowOffsetY{(shadowOffsetY).gget}def
/.getShadowBlur{(shadowBlur).gget}def
/.getShadowColor{(shadowColor).gget}def
/.getFont{(font).gget}def
/.getTextAlign{(textAlign).gget}def
/.getTextBaseline{(textBaseline).gget}def

/.setGlobalAlpha{(globalAlpha).gput}def
/.setGlobalCompositeOperation{(globalCompositeOperation).gput}def
/.setStrokeStyle{(strokeStyle).gput}def
/.setFillStyle{(fillStyle).gput}def
/.setLineWidth{(lineWidth).gput}def
/.setLineCap{(lineCap).gput}def
/.setLineJoin{(lineJoin).gput}def
/.setMiterLimit{(miterLimit).gput}def
/.setShadowOffsetX{(shadowOffsetX).gput}def
/.setShadowOffsetY{(shadowOffsetY).gput}def
/.setShadowBlur{(shadowBlur).gput}def
/.setShadowColor{(shadowColor).gput}def
/.setFont{(font).gput}def
/.setTextAlign{(textAlign).gput}def
/.setTextBaseline{(textBaseline).gput}def

%% PostScript

/.deg2rad{.pi 180 div mul}def
/.rad2deg{180 .pi div mul}def

/identmatrix{pop [1 0 0 1 0 0]}def % TODO fill
/matrix{6 array identmatrix}def

/.cx 0 def
/.cy 0 def
/.px 0 def
/.py 0 def
/.tm matrix def
/.tmd matrix def

/.setPoint{/.cy exch def/.cx exch def}def
/.setPath{/.py exch def/.px exch def}def

/.update{ % m --
  dup .cx exch .cy exch % m .cx .cy m
  .xy .setPoint % m
  dup .tmd exch .mmul/.tmd exch def % (.tmd x m)
  .tm exch .mmul setmatrix % = .tm x m
} def

/transform{dup type(arraytype)ne{.tmd}if .xy}def % TODO why .tmd not .tm?
/itransform{dup type(arraytype)ne{.tmd}if .minv .xy}def % TODO why .tmd not .tm?

/.scaleM{0 0 3 2 roll 0 0 6 array astore}def % x y -- [x 0 0 y 0 0]
/.scale3{pop .scaleM}def
/.scale2{2 copy .scaleM .update .scale}def
/scale{dup type(arraytype)eq{.scale3}{.scale2}ifelse}def

/.translateM{1 0 0 1 6 4 roll 6 array astore}def % x y -- [1 0 0 1 x y]
/.translate3{pop .translateM}def
/.translate2{2 copy .translateM .update .translate}def
/translate{dup type(arraytype)eq{.translate3}{.translate2}ifelse}def

/.rotateM{dup cos exch sin dup neg 2 index 0 0 6 array astore}def % a -- [c s -s c 0 0]
/.rotate2{pop .deg2rad .rotateM}def
/.rotate1{.deg2rad dup .rotateM .update .rotate}def
/rotate{dup type(arraytype)eq{.rotate2}{.rotate1}ifelse}def

/currentpoint{.cx .cy}def

/setmatrix{/.tm exch def}def

%– initmatrix – 	Set CTM to device default
%matrix defaultmatrix matrix 	Fill matrix with device default matrix
%matrix currentmatrix matrix 	Fill matrix with CTM

%matrix concat – 	Replace CTM by matrix ´ CTM
%matrix1 matrix2 matrix3 concatmatrix matrix3 	Fill matrix3 with matrix1 ´ matrix2

%dx dy dtransform dx¢ dy¢ 	Transform distance (dx, dy) by CTM
%dx dy matrix dtransform dx¢ dy¢ 	Transform distance (dx, dy) by matrix

%dx¢ dy¢ idtransform dx dy 	Perform inverse transform of distance (dx¢, dy¢) by CTM
%dx¢ dy¢ matrix idtransform dx dy 	Perform inverse transform of distance (dx¢, dy¢) by matrix

%matrix1 matrix2 invertmatrix matrix2 	Fill matrix2 with inverse of matrix1

/gsave{.save}def
/grestore{.restore}def
/rectclip{.clipRect}def
/rectfill{.fillRect}def
/rectstroke{.strokeRect}def
/newpath{.beginPath}def
/closepath{.closePath}def
/moveto{2 copy .setPoint 2 copy .setPath/.tmd matrix def .moveTo}def
/lineto{2 copy .setPoint 2 copy .setPath/.tmd matrix def .lineTo}def
/arcto{.arcTo}def

/setlinewidth{.setLineWidth}def
/setlinecap{.setLineCap}def % TODO
/setlinejoin{.setLineJoin}def % TODO
/setmiterlimit{.setMiterLimit}def

/currentlinewidth{.getLineWidth}def
/currentlinecap{<</butt 0/round 1/square 2>> .getLineCap get}def
/currentlinejoin{<</miter 0/round 1/bevel 2>> .getLineJoin get}def
/currentmiterlimit{.getMiterLimit}def

/setgray{255 mul dup dup .rgb dup .setStrokeStyle .setFillStyle}def
/setrgbcolor{3{255 mul round 3 1 roll}repeat .rgb dup .setStrokeStyle .setFillStyle}def
/setfont{} def % TODO C.font = N + "pt " + F.V;
/clippath{0 0 .gcanvas(width)get .gcanvas(height)get .rect}def % TODO
/show{currentpoint 3 2 roll 3 copy .fillText .strokeText}def % TODO

/rlineto{.tmd .xy .py add exch .px add exch .tmd .minv .xy lineto}def

/currentflat{42}def % TODO
/setflat{pop}def % TODO

/showpage{}def % TODO

/arc{.deg2rad exch .deg2rad exch true .arc}def % TODO currentpoint
/arcn{.deg2rad exch .deg2rad exch false .arc}def % TODO currentpoint

/fill{.fill newpath currentpoint .moveTo}def % TODO

/setdash{pop pop}def % TODO

/stroke{.stroke newpath currentpoint .moveTo}def

/curveto{2 copy .setPoint 2 copy .setPath/.tmd matrix def .bezierCurveTo}def

/grestoreall{}def % TODO

%% PDF

/w{setlinewidth}def
/J{setlinecap}def % TODO
/j{setlinejoin}def % TODO
/M{setmitterlimit}def
/d{setdash}def % TODO
/ri{}def % TODO
/i{}def % TODO
/gs{}def % TODO
/q{gsave}def
/Q{grestore}def
/cm{.transform}def
/m{newpath moveto}def % TODO only if not m previously
/l{lineto}def
/c{.bezierCurveTo}def
/v{currentpoint cp2 p3 c}def % TODO fix arg order
/y{cp1 p3 p3 c}def % TODO fix arg order
/h{closepath}def % TODO
/re{.rect}def % TODO really, or x y m , x+w y l , x+w y+h l , x y+h l , h
/S{stroke}def
/s{h S}def
/f{fill}def % TODO
/F{f}def
/f*{}def % TODO
/B{f S}def
/B*{f* S}def
/b{h B}def
/b*{h B*}def
/n{}def % TODO
/W{clip}def % TODO
/W*{clip}def % TODO
/BT{}def % TODO
/ET{}def % TODO
/Tc{}def % TODO
/Tw{}def % TODO
/Tz{}def % TODO
/TL{}def % TODO
/Tf{setfont}def % TODO
/Tr{}def % TODO
/Ts{}def % TODO
/Td{translate 0 0 moveto}def
/TD{}def % TODO
/Tm{}def % TODO
/T*{}def % TODO
/Tj{show}def % TODO
/TJ{}def % TODO
/'{}def % TODO
/"{}def % TODO
/d0{}def % TODO
/d1{}def % TODO
/CS{}def % TODO
/cs{}def % TODO
/SC/setcolor load def
/SCN{}def % TODO
/sc/setcolor load def
/scn{}def % TODO
/G{}def % TODO
/g{}def % TODO
/RG{}def % TODO
/rg{setrgbcolor}def % TODO
/K{}def % TODO
/k{}def % TODO
/sh{}def % TODO
/BI{}def % TODO
/ID{}def % TODO
/EI{}def % TODO
/Do{}def % TODO
/MP{}def % TODO
/DP{}def % TODO
/BMC{}def % TODO
/BDC{}def % TODO
/EMC{}def % TODO
/BX{}def % TODO
/EX{}def % TODO

% /Operators 50 dict begin
%   /cs { //ResolveColorSpace exec //SetColorSpaceSafe exec
%       } bind def
%   /scn { //SetColor exec } bind def
%   /CS //cs def
%   /SCN { //SetColor exec } bind def

%   /re {
%     4 2 roll moveto  exch dup 0 rlineto  0 3 -1 roll rlineto  neg 0 rlineto
%     closepath
%   } def
%   /sh { % Reserved for ps3write.
%         ResolveShading 
%         dup /Background known {
%           gsave
%           dup /ColorSpace get setcolorspace
%           dup /Background get aload pop setcolor
%           pathbbox               % x0 y0 x1 y1
%           2 index sub exch 3 index sub exch
%           rectfill
%           grestore
%         } if
%         shfill 
%       } bind def

%   /Do { //DoXObject exec } bind def

%   /BI { currentglobal false setglobal << } bind def
%   /ID { >>
%         dup /DataSource currentfile 
%         % HACK BEG
%         % This hack provides a compatibility to HP LaserJet 1320,
%         % which sometimes closes the underlying stream when EOD 
%         % is reached in the ASCII85Decode filter.
%         % This portion is not required by the Postscript language definition.
%         2 index /F //knownget exec {
%           /A85 eq {
%             0 (~>) /SubFileDecode filter 
%           } if
%         } if
%         % HACK END
%         put
%         //CompleteInlineImage exec
%         exch setglobal
%         //DoImage exec
%       } bind def
%   /EI {} bind def

%   /BT { gsave //GraphicState /InitialTextMatrix get currentmatrix pop } bind def
%   /Tc { //GraphicState exch /CharacterSpacing exch put } bind def
%   /TL { //GraphicState exch /TextLeading exch put } bind def
%   /Tr { //GraphicState exch /TextRenderingMode exch put } bind def
%   /Ts {  % Ghostscript never generates it.
%         mark (Unimplemented SetTextRise) //error exec
%       } bind def
%   /Tw { //GraphicState exch /WordSpacing exch put } bind def
%   /Tz { % Ghostscript never generates it.
%             mark (Unimplemented SetHorizontalTextScaling) //error exec
%       } bind def
%   /TD { dup neg //TL exec //Td exec } bind def
%   /Tm { //GraphicState /InitialTextMatrix get setmatrix
%         //TempMatrix astore concat
%         0 0 moveto } bind def
%   /T* { 0 //GraphicState /TextLeading get neg //Td exec } bind def
%   /Tj { //ShowTextBeg exec  //ShowText exec  //ShowTextEnd exec } bind def
%   /'  { //T* exec  //ShowText exec  //ShowTextEnd exec } bind def
%   /"  { 3 2 roll //Tw exec exch //Tc exec //' exec} bind def
%   /TJ //ShowTextWithGlyphPositioning def
%   /Tf //SetFont def

%   /BDC { BeginMarkedContentSequenceWithPropertyList } bind def
%   /BMC { BeginMarkedContentSequence } bind def
%   /EMC { EndMarkedContentSequence } bind def
%   /BX { BeginCompatibilitySection } bind def
%   /EX { EndCompatibilitySection } bind def
%   /DP { DefineMarkedContentPointWithPropertyList } bind def
%   /MP { DefineMarkedContentPoint } bind def
% currentdict end def

%% finish

/userdict 1000 dict def
userdict begin
